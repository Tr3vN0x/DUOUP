<script>
// ---------- FIREBASE INIT (YOUR CONFIG) ----------
const firebaseConfig = {
    apiKey: "AIzaSyDVHxatohLvJNqIHXjf1ZXdmmWX5W1EpNw",    
    authDomain: "duoup-cfae6.firebaseapp.com",
    projectId: "duoup-cfae6",
    storageBucket: "duoup-cfae6.firebasestorage.app",
    messagingSenderId: "812263060524",
    appId: "1:812263060524:web:ac09c3ae610db1cd110d89",
    measurementId: "G-46B67F90FK"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const storage = firebase.storage();

// OWNER UID (Used for a display badge)
const OWNER_UID = "DecuxiBRxoSwb8wKMmaHQql9HQ2"; // Replace with actual owner UID
const DEFAULT_AVATAR = "https://cdn-icons-png.flaticon.com/512/149/149071.png";

// Common Game and Role Lists for Selection
const GAMES_LIST = [
    { name: "Apex Legends", roles: ["Tank", "DPS", "Support", "Any"] },
    { name: "Valorant", roles: ["Duelist", "Controller", "Sentinel", "Initiator", "Any"] },
    { name: "League of Legends", roles: ["Top", "Jungle", "Mid", "ADC", "Support", "Any"] },
    { name: "Dota 2", roles: ["Carry", "Mid", "Offlane", "Support 4", "Support 5", "Any"] },
    { name: "Overwatch 2", roles: ["Tank", "DPS", "Support", "Any"] },
    { name: "Fortnite", roles: ["Builder", "Zero Build", "Any"] },
    { name: "Destiny 2", roles: ["PVE", "PVP", "Any"] },
    { name: "Rocket League", roles: ["Attacker", "Defender", "Midfield", "Any"] },
    { name: "Other/Casual", roles: ["Chill", "Competitive", "Casual"] }
];

// Global State
let currentUser = null, 
    currentChatUid = null, 
    unsubscribeMessages = null, 
    unsubscribeUnread = null; 
let currentProfileData = {}; 
let pendingRequests = {}; 
let sentRequests = {};   
let allUsersCache = [];    
let friendUsers = {}; 
let blockedUsers = {}; // UIDs blocked by the current user

/**
 * Helper to get the canonical Chat/Request ID used by the rules (sorted UIDs).
 */
function getCanonicalRequestId(a,b){ return [a,b].sort().join('_'); }

// ---------- AUTH & INITIALIZATION ----------
function login(){ auth.signInWithPopup(new firebase.auth.GoogleAuthProvider()).catch(e=>alert(e.message)); }
function logout(){ 
    if(unsubscribeMessages) unsubscribeMessages(); 
    if(unsubscribeUnread) unsubscribeUnread(); 
    auth.signOut(); 
}

auth.onAuthStateChanged(async user=>{
    if(!user){ loginPage.classList.remove("hidden"); dashboard.classList.add("hidden"); return; }
    
    loginPage.classList.add("hidden"); dashboard.classList.remove("hidden"); currentUser=user;
    
    const userRef=db.collection("users").doc(user.uid);
    const userDoc = await userRef.get();

    // 1. New User Setup (If profile doesn't exist or is missing new fields)
    if(!userDoc.exists || !userDoc.data().featuredGames){
        const baseName = (user.displayName || user.email.split('@')[0]).replace(/\s/g, '').toLowerCase();
        const defaultUsername = baseName.substring(0, 16).slice(0, 16 - 4) + Math.floor(1000 + Math.random() * 9000); 
        
        // Ensure new fields exist for new and existing users
        const profileUpdate = {
            uid: user.uid,
            username: userDoc.exists ? (userDoc.data().username || defaultUsername) : defaultUsername,
            usernameChanged: userDoc.exists ? (userDoc.data().usernameChanged || false) : false,
            bio: userDoc.exists ? (userDoc.data().bio || "New Cyber Warrior seeking a Duo partner!") : "New Cyber Warrior seeking a Duo partner!",
            skillRating: userDoc.exists ? (userDoc.data().skillRating || 3) : 3,
            status: userDoc.exists ? (userDoc.data().status || "Online") : "Online",
            friends: userDoc.exists ? (userDoc.data().friends || []) : [],
            profileImageUrl: user.photoURL || DEFAULT_AVATAR,
            nickname: user.displayName, 
            gamerCards: userDoc.exists ? (userDoc.data().gamerCards || []) : [],
            featuredGames: userDoc.exists ? (userDoc.data().featuredGames || []) : [], // NEW FIELD
        };
        
        await userRef.set(profileUpdate, { merge: true });

        // Only set username doc if new user
        if (!userDoc.exists) {
            await db.collection("usernames").doc(defaultUsername).set({
                uid: user.uid,
                username: defaultUsername
            });
        }
    }
    
    // 2. Load Core Data
    await loadUserProfile(); 
    await loadRelationshipStatus(); 
    await loadBlocks(); 

    // 3. Load UI Data
    welcome.textContent=`Welcome, ${currentUser.displayName || currentUser.email}`;
    await loadAllUsers(); 
    loadFriendRequests();
    await loadFriends();
    // initMessaging(); // Placeholder
});


// Helper to track sent/received requests
async function loadRelationshipStatus() {
    if (!currentUser) return;
    pendingRequests = {};
    sentRequests = {};

    const incomingSnap = await db.collection("friendRequests")
        .where("receiverId", "==", currentUser.uid)
        .get();
    incomingSnap.forEach(doc => {
        pendingRequests[doc.data().senderId] = doc.id;
    });

    const outgoingSnap = await db.collection("friendRequests")
        .where("senderId", "==", currentUser.uid)
        .get();
    outgoingSnap.forEach(doc => {
        sentRequests[doc.data().receiverId] = doc.id;
    });
}

// Loads UIDs blocked by the current user
async function loadBlocks() {
    if (!currentUser) return;
    blockedUsers = {};
    
    const blocksSnap = await db.collection("blocks")
        .where("blockerId", "==", currentUser.uid) 
        .get();
        
    blocksSnap.forEach(doc => {
        // The document ID is blockerId_blockedId
        const blockedUid = doc.id.split('_')[1];
        blockedUsers[blockedUid] = doc.id;
    });
}

// Loads user profile data for the editor
async function loadUserProfile() {
    const userDoc = await db.collection("users").doc(currentUser.uid).get();
    currentProfileData = userDoc.data() || {}; 

    profileAvatar.src = currentProfileData.profileImageUrl || DEFAULT_AVATAR;
    
    const currentDisplayUsername = currentProfileData.username || 'Loading...';

    profileNickname.value = currentProfileData.nickname || currentUser.displayName || "Unknown User";
    
    profileBio.value = currentProfileData.bio || "";
    profileSkillRating.value = currentProfileData.skillRating || "3";
    profileStatus.value = currentProfileData.status || "Online";

    document.getElementById("usernameDisplay").textContent = `@${currentDisplayUsername}`;
    
    const changeBtn = document.getElementById("changeUsernameBtn");
    const input = document.getElementById("newUsernameInput");
    const messageElement = document.getElementById("usernameMessage");

    const hasChanged = currentProfileData.usernameChanged === true;
    
    if (hasChanged) {
        changeBtn.textContent = "Changed Once (Locked)";
        changeBtn.disabled = true;
        input.disabled = true;
        messageElement.textContent = "Your unique username has been permanently set.";
    } else {
        changeBtn.textContent = "Set/Change Username";
        changeBtn.disabled = false;
        input.disabled = false;
        messageElement.textContent = "You have one change remaining to set your unique @handle.";
    }
    
    renderGameSlots(); // Render the game slots
}


// --- GAME SLOTS LOGIC ---

function renderGameSlots() {
    const gameSlotList = document.getElementById('gameSlotList');
    const featuredGames = currentProfileData.featuredGames || [];
    gameSlotList.innerHTML = '';
    
    // Update button visibility
    document.getElementById('addGameBtn').disabled = featuredGames.length >= 4;

    featuredGames.forEach((game, index) => {
        const slot = document.createElement('div');
        slot.className = 'game-slot';
        slot.innerHTML = `
            <button class="remove-game-btn" onclick="removeGameSlot(${index})">X</button>
            <h4>Game ${index + 1}</h4>
            <label style="font-size: 0.9em; color: gray;">Game Title:</label>
            <select data-index="${index}" data-field="game" onchange="updateGameRoleOptions(this.value, ${index})">
                <option value="">-- Select Game --</option>
                ${GAMES_LIST.map(g => `<option value="${g.name}" ${g.name === game.game ? 'selected' : ''}>${g.name}</option>`).join('')}
            </select>
            <label style="font-size: 0.9em; color: gray;">Role/Need:</label>
            <select data-index="${index}" data-field="role" class="role-select-${index}">
                ${generateRoleOptions(game.game, game.role)}
            </select>
        `;
        gameSlotList.appendChild(slot);
    });
}

function generateRoleOptions(gameName, selectedRole) {
    const game = GAMES_LIST.find(g => g.name === gameName);
    const roles = game ? game.roles : ["Any"];
    return roles.map(r => `<option value="${r}" ${r === selectedRole ? 'selected' : ''}>${r}</option>`).join('');
}

function updateGameRoleOptions(gameName, index) {
    const select = document.querySelector(`.role-select-${index}`);
    if (select) {
        select.innerHTML = generateRoleOptions(gameName, "");
    }
}

function addGameSlot() {
    if (currentProfileData.featuredGames.length < 4) {
        currentProfileData.featuredGames.push({
            game: GAMES_LIST[0].name, // Default to first game
            role: GAMES_LIST[0].roles[0] // Default to first role
        });
        renderGameSlots();
    } else {
        alert("Maximum of 4 featured games allowed.");
    }
}

function removeGameSlot(index) {
    currentProfileData.featuredGames.splice(index, 1);
    renderGameSlots();
}

async function saveProfile() {
    const featuredGames = [];
    const gameSlots = document.querySelectorAll('#gameSlotList .game-slot');
    let hasError = false;

    gameSlots.forEach((slot, index) => {
        const gameSelect = slot.querySelector(`select[data-field="game"]`);
        const roleSelect = slot.querySelector(`select[data-field="role"]`);
        
        if (gameSelect.value && roleSelect.value) {
            featuredGames.push({
                game: gameSelect.value,
                role: roleSelect.value
            });
        } else if (gameSelect.value || roleSelect.value) {
             hasError = true;
        }
    });
    
    if (hasError) {
        alert("Please ensure every selected game slot has both a Game Title and a Role/Need selected, or remove the slot.");
        return;
    }

    const updateData = {
        bio: profileBio.value,
        skillRating: parseInt(profileSkillRating.value),
        status: profileStatus.value,
        featuredGames: featuredGames, // Save the collected game data
    };
    
    try {
        await db.collection("users").doc(currentUser.uid).update(updateData);
        document.getElementById('saveMessage').textContent = 'Profile saved successfully!';
        setTimeout(() => document.getElementById('saveMessage').textContent = '', 3000);
        await loadUserProfile(); // Reload data to reflect changes
        loadAllUsers();
    } catch(e) {
        document.getElementById('saveMessage').textContent = `Error saving profile: ${e.message}`;
        console.error("Save Profile Error:", e);
    }
}

// --- END GAME SLOTS LOGIC ---


// --- TAB MANAGEMENT ---
function showTab(tab){
    document.querySelectorAll('#allUsersTab, #searchTab, #requestsTab, #friendsTab, #messagingTab, #profileTab, #viewProfileTab').forEach(el => el.classList.add('hidden'));
    
    switch(tab){
      case "allUsers": document.getElementById('allUsersTab').classList.remove("hidden"); loadAllUsers(); break; 
      case "search": document.getElementById('searchTab').classList.remove("hidden"); filterSearchResults(); break; 
      case "requests": document.getElementById('requestsTab').classList.remove("hidden"); loadFriendRequests(); break; 
      case "friends": document.getElementById('friendsTab').classList.remove("hidden"); loadFriends(); break; 
      case "messaging": document.getElementById('messagingTab').classList.remove("hidden"); /* initMessaging(); */ break;
      case "profile": document.getElementById('profileTab').classList.remove("hidden"); loadUserProfile(); break; 
      case "viewProfile": document.getElementById('viewProfileTab').classList.remove("hidden"); break; 
    }
}


// ---------- CORE USER CARD RENDERING (UPDATED) ----------

function renderUserCard(d, data) {
    const nickname = data.nickname || "Unknown Player";
    const username = data.username ? `@${data.username}` : nickname;
    const profileImageUrl = data.profileImageUrl || DEFAULT_AVATAR;
    const skillRating = data.skillRating || 0; 
    const status = data.status || "Offline";
    const statusClass = status.replace(/\s/g, "").toLowerCase(); 
    const firstGamerCard = (data.gamerCards && data.gamerCards.length > 0) ? data.gamerCards[0] : null; 
    
    // Check if the card belongs to the current user
    const isCurrentUser = d.id === currentUser.uid;

    const card = document.createElement("div");
    card.className = "card";
    // Only allow viewing other people's profiles
    if (!isCurrentUser) {
        card.onclick = () => viewUserProfile(d.id); 
    }
    
    // Check if the user is the specific OWNER_UID
    const isOwner = d.id === OWNER_UID;

    let cardContentHTML = `
        <div class="card-content-box">
            <img src="${profileImageUrl}" class="avatar">
            <strong>${username}</strong> ${isOwner ? '<span class="owner-badge-box">OWNER</span>' : ''}
            <span class="skill-rating">${'⭐'.repeat(skillRating)}</span>
            <span class="status-indicator status-${statusClass}">${status}</span>
        </div>`;

    if (firstGamerCard) {
        cardContentHTML += `<img src="${firstGamerCard}" class="card-gamer-preview" alt="Gamer Card Preview">`;
    }
    
    // Display featured games
    const featuredGames = data.featuredGames || [];
    if (featuredGames.length > 0) {
        cardContentHTML += `<div class="card-games">`;
        featuredGames.forEach(g => {
            cardContentHTML += `<span class="game-badge">${g.game} (${g.role})</span>`;
        });
        cardContentHTML += `</div>`;
    }


    card.innerHTML = cardContentHTML;

    let actionBtn = null;
    let statusText = null;
    
    // Only show buttons/status for non-current user cards
    if (!isCurrentUser) {
        if (currentProfileData.friends && currentProfileData.friends.includes(d.id)) {
            statusText = document.createElement("p");
            statusText.style.color = 'lime';
            statusText.textContent = "✅ Duo Partner";
        } else if (pendingRequests[d.id]) {
            statusText = document.createElement("p");
            statusText.style.color = 'yellow';
            statusText.textContent = "❗ Incoming Request";
        } else if (sentRequests[d.id]) {
            statusText = document.createElement("p");
            statusText.style.color = 'orange';
            statusText.textContent = "⏳ Request Sent";
        } else if (!blockedUsers[d.id]) {
            actionBtn = document.createElement("button");
            actionBtn.className = "neon-btn";
            actionBtn.textContent = "Send Duo Request";
            actionBtn.onclick = (e) => { e.stopPropagation(); sendFriendRequest(d.id); };
        }
    }
    
    if (actionBtn) card.appendChild(actionBtn);
    if (statusText && !pendingRequests[d.id]) card.appendChild(statusText); 

    return card;
}


// ---------- USER & SEARCH FUNCTIONS (RESTORED) ----------

async function loadAllUsers(){
    allUsersTab.innerHTML = "<h3>Suggested Players</h3>";
    
    if (allUsersCache.length === 0) {
        try {
            // This is the query that requires the permissive read rule (Rule 1)
            const querySnap=await db.collection("users").get();
            allUsersCache = querySnap.docs.map(d => ({
                id: d.id,
                data: d.data()
            }));
        } catch(e) {
            console.error("Error loading all users:", e);
            allUsersTab.innerHTML += `<p style="color:red;">Error loading players: ${e.message}. Check console for details.</p>`;
            return;
        }
    }

    if (allUsersCache.length === 0) {
           allUsersTab.innerHTML += "<p>No other players found in the database.</p>";
           return;
    }

    allUsersCache.forEach(({id, data})=>{
      if(id === currentUser.uid || blockedUsers[id]) return; 
      
      const card = renderUserCard({id}, data); 
      allUsersTab.appendChild(card);
    });
}

function filterSearchResults() {
    const searchResults = document.getElementById('searchResults');
    searchResults.innerHTML = "";
    
    const query = document.getElementById('searchInput').value.toLowerCase();
    const statusFilter = document.getElementById('statusFilter').value;
    const minSkill = parseInt(document.getElementById('skillFilter').value);

    const filtered = allUsersCache.filter(({id, data}) => {
        if (id === currentUser.uid || blockedUsers[id]) return false;

        const bio = (data.bio || '').toLowerCase();
        const nickname = (data.nickname || '').toLowerCase();
        const username = (data.username || '').toLowerCase();

        if (query && !(nickname.includes(query) || bio.includes(query) || username.includes(query))) {
            return false;
        }

        if (statusFilter && data.status !== statusFilter) {
            return false;
        }

        if (minSkill > 0 && (data.skillRating || 0) < minSkill) {
            return false;
        }

        return true;
    });

    if (filtered.length === 0) {
        searchResults.innerHTML = "<p>No players match your search criteria.</p>";
    } else {
        filtered.forEach(({id, data}) => {
            const card = renderUserCard({id}, data);
            searchResults.appendChild(card);
        });
    }
}


// ---------- FRIEND REQUEST FUNCTIONS (FIXED) ----------

/**
 * FIX: Sends a friend request, ensuring the canonical ID is calculated 
 * and used with .set() to pass Security Rule 3.
 * @param {string} receiverId - The UID of the target user.
 */
async function sendFriendRequest(receiverId) {
    if (!currentUser) return;
    const senderId = currentUser.uid;

    const requestId = getCanonicalRequestId(senderId, receiverId);
    const requestRef = db.collection("friendRequests").doc(requestId);

    const requestData = {
        senderId: senderId,
        receiverId: receiverId,
        status: 'pending',
        createdAt: firebase.firestore.FieldValue.serverTimestamp() 
    };

    try {
        await requestRef.set(requestData);
        console.log("Duo Request sent successfully to:", receiverId);
        // Refresh status and UI
        await loadRelationshipStatus();
        showTab('allUsers'); // Refresh the list view
    } catch (e) {
        console.error("Friend Request Send Error:", e);
        alert("Friend Request Send Error: " + e.message);
    }
}


/**
 * FIX: Loads incoming friend requests and displays them on the Requests tab.
 */
async function loadFriendRequests() {
    const requestsTab = document.getElementById('requestsTab');
    requestsTab.innerHTML = "<h3>Incoming Duo Requests</h3>";
    
    if (Object.keys(pendingRequests).length === 0) {
        requestsTab.innerHTML += "<p>You have no pending duo requests.</p>";
        return;
    }

    // Get the profiles of the senders
    const senderUids = Object.keys(pendingRequests);
    const senderPromises = senderUids.map(uid => db.collection("users").doc(uid).get());
    const senderDocs = await Promise.all(senderPromises);

    senderDocs.forEach(doc => {
        if (!doc.exists) return;
        const senderData = doc.data();
        const senderId = doc.id;
        
        const card = document.createElement('div');
        card.className = 'card';
        card.style.maxWidth = '100%';
        
        card.innerHTML = `
            <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                <div style="display:flex; align-items:center;" onclick="viewUserProfile('${senderId}')">
                    <img src="${senderData.profileImageUrl || DEFAULT_AVATAR}" class="avatar" style="margin-right:15px;">
                    <strong>@${senderData.username || senderData.nickname}</strong>
                </div>
                <div>
                    <button class="neon-btn accept" onclick="acceptFriendRequest('${senderId}')">Accept Duo</button>
                    <button class="neon-btn remove" onclick="declineFriendRequest('${senderId}')">Decline</button>
                </div>
            </div>
        `;
        requestsTab.appendChild(card);
    });
}


/**
 * FIX: Accepts a friend request using a transaction, satisfying 
 * Pattern C (isTransactionalFriendUpdate) in the Security Rules.
 * @param {string} senderId - The UID of the user who sent the request.
 */
async function acceptFriendRequest(senderId) {
    if (!currentUser) return;
    const receiverId = currentUser.uid;
    const requestId = getCanonicalRequestId(senderId, receiverId);

    const requestRef = db.collection("friendRequests").doc(requestId);
    const senderRef = db.collection("users").doc(senderId);
    const receiverRef = db.collection("users").doc(receiverId);

    try {
        await db.runTransaction(async (t) => {
            // 1. DELETE: Delete the friend request document (Rule 3 delete check)
            t.delete(requestRef);

            // 2. UPDATE SENDER: Add receiver to sender's friends list (Rule 1, Pattern C)
            t.update(senderRef, {
                friends: firebase.firestore.FieldValue.arrayUnion(receiverId),
            });

            // 3. UPDATE RECEIVER: Add sender to receiver's friends list (Rule 1, Pattern A)
            t.update(receiverRef, {
                friends: firebase.firestore.FieldValue.arrayUnion(senderId),
            });
        });
        
        alert(`Duo formed with ${senderId.substring(0, 8)}...`);
        // Reload all data
        await loadRelationshipStatus();
        await loadUserProfile();
        showTab('requests'); // Refresh the requests view

    } catch (e) {
        console.error("Accept Request Transaction Failed:", e);
        alert("Accept Request Failed: " + e.message);
    }
}

/**
 * Handles decline and withdrawal (deletion) of a friend request.
 * @param {string} otherUid - The UID of the sender (if declining) or receiver (if withdrawing).
 */
async function declineFriendRequest(otherUid) {
    if (!currentUser) return;
    const requestId = getCanonicalRequestId(currentUser.uid, otherUid);
    
    try {
        await db.collection("friendRequests").doc(requestId).delete();
        alert("Request successfully withdrawn/declined.");
        
        // Reload all data
        await loadRelationshipStatus();
        showTab('requests'); // Refresh the requests view

    } catch (e) {
        console.error("Decline/Withdraw Error:", e);
        alert("Error handling request: " + e.message);
    }
}


// ---------- FRIEND/BLOCK REMOVAL FUNCTIONS ----------

async function loadFriends() {
    friendsTab.innerHTML = "<h3>Your Duo Partners</h3>";
    const friendUids = currentProfileData.friends || [];
    
    if (friendUids.length === 0) {
        friendsTab.innerHTML += "<p>You don't have any Duo Partners yet. Find someone in Suggested!</p>";
        return;
    }

    const friendPromises = friendUids.map(uid => db.collection("users").doc(uid).get());
    const friendDocs = await Promise.all(friendPromises);

    friendDocs.forEach(doc => {
        if (!doc.exists) return;
        const data = doc.data();
        const friendId = doc.id;
        
        const card = document.createElement('div');
        card.className = 'card';
        card.style.maxWidth = '100%';
        
        card.innerHTML = `
            <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                <div style="display:flex; align-items:center;" onclick="viewUserProfile('${friendId}')">
                    <img src="${data.profileImageUrl || DEFAULT_AVATAR}" class="avatar" style="margin-right:15px;">
                    <strong>@${data.username || data.nickname}</strong>
                </div>
                <div>
                    <button class="neon-btn remove" onclick="removeFriend('${friendId}')">Remove Duo</button>
                    <button class="neon-btn" onclick="startChat('${friendId}')">Message</button>
                </div>
            </div>
        `;
        friendsTab.appendChild(card);
    });
}

/**
 * Removes a friend from both users' friends arrays.
 */
async function removeFriend(friendId) {
    if (!confirm(`Are you sure you want to remove ${friendId.substring(0, 8)}... as a Duo Partner?`)) return;
    
    const currentUserRef = db.collection("users").doc(currentUser.uid);
    const friendUserRef = db.collection("users").doc(friendId);
    
    try {
        // Remove friend from current user's list (Rule 1, Pattern A: General Self-Update)
        await currentUserRef.update({
            friends: firebase.firestore.FieldValue.arrayRemove(friendId)
        });
        
        // Remove current user from friend's list (Rule 1, Pattern A: General Self-Update is NOT used here! 
        // This is a violation, so a Cloud Function is required for proper removal.
        // For client-only rules, you have to rely on the friend being able to remove you, or manually update
        // their profile IF you had permission, which you don't here.)
        // For a true fix without CF, the friend MUST run the removal client-side.
        // For this demo, we use a relaxed client-side rule violation for simplicity:
        await friendUserRef.update({
             friends: firebase.firestore.FieldValue.arrayRemove(currentUser.uid)
        }); 

        alert("Duo Partner removed. Note: Partner's list might not update immediately due to client-only rules.");
        await loadUserProfile();
        showTab('friends');
        loadAllUsers();
    } catch(e) {
        console.error("Remove Friend Error:", e);
        alert("Error removing friend: " + e.message);
    }
}

/**
 * Blocks another user. Creates a document in /blocks.
 */
async function blockUser(blockedId) {
    if (!confirm(`Are you sure you want to block ${blockedId.substring(0, 8)}...? This cannot be undone easily.`)) return;
    
    const blockId = `${currentUser.uid}_${blockedId}`; // Must be currentUser's UID first (Rule 4)
    
    try {
        await db.collection("blocks").doc(blockId).set({
            blockerId: currentUser.uid,
            blockedId: blockedId,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        alert("User blocked successfully.");
        await loadBlocks();
        showTab('allUsers'); 
    } catch (e) {
        console.error("Block User Error:", e);
        alert("Error blocking user: " + e.message);
    }
}

// ---------- VIEW PROFILE (COMPLETED) ----------

async function viewUserProfile(uid) {
    showTab('viewProfile');
    
    const userDoc = await db.collection("users").doc(uid).get();
    const data = userDoc.data();
    const viewProfileContent = document.getElementById('viewProfileContent');
    
    if (!data) {
        viewProfileContent.innerHTML = `<p style="color:red;">Error: Profile not found.</p>`;
        return;
    }

    const gamesHtml = (data.featuredGames || []).map(g => 
        `<span class="game-badge">${g.game} (${g.role})</span>`
    ).join('');

    const isFriend = (currentProfileData.friends || []).includes(uid);
    const isSent = sentRequests[uid];
    const isPending = pendingRequests[uid];
    const isBlocked = blockedUsers[uid];
    
    const isOwner = uid === OWNER_UID;
    const ownerBadgeHtml = isOwner ? '<span class="owner-badge-box">OWNER</span>' : '';

    let actionButtonsHtml = '';

    if (isBlocked) {
        actionButtonsHtml = `<button class="neon-btn" onclick="unblockUser('${uid}')" style="border-color:orange; box-shadow:0 0 10px orange;">Unblock User</button>`;
    } else if (isFriend) {
        actionButtonsHtml = `
            <button class="neon-btn remove" onclick="removeFriend('${uid}')">Remove Duo</button>
            <button class="neon-btn" onclick="startChat('${uid}')">Start Chat</button>`;
    } else if (isPending) {
         actionButtonsHtml = `
            <button class="neon-btn accept" onclick="acceptFriendRequest('${uid}')">Accept Duo</button>
            <button class="neon-btn remove" onclick="declineFriendRequest('${uid}')">Decline</button>`;
    } else if (isSent) {
        actionButtonsHtml = `<button class="neon-btn remove" onclick="declineFriendRequest('${uid}')">Cancel Request</button>`;
    } else {
        actionButtonsHtml = `
            <button class="neon-btn" onclick="sendFriendRequest('${uid}')">Send Duo Request</button>
            <button class="neon-btn remove" onclick="blockUser('${uid}')" style="border-color:red; box-shadow:0 0 10px red;">Block</button>`;
    }

    viewProfileContent.innerHTML = `
        <div style="display: flex; gap: 30px; align-items: flex-start; margin-bottom: 20px;">
            <img class="avatar" style="width: 100px; height: 100px; border-color: cyan;" src="${data.profileImageUrl || DEFAULT_AVATAR}">
            <div>
                <h3 style="margin: 0; color: magenta;">@${data.username || data.nickname} ${ownerBadgeHtml}</h3>
                <p style="color: gray; margin: 5px 0 10px 0;">${data.nickname || 'No Nickname'}</p>
                <span class="skill-rating">${'⭐'.repeat(data.skillRating || 0)}</span>
                <span class="status-indicator status-${data.status.replace(/\s/g, "").toLowerCase()}">${data.status}</span>
                <div style="margin-top: 15px;">${actionButtonsHtml}</div>
            </div>
        </div>
        <div style="padding-top: 15px; border-top: 1px dashed #333;">
            <h4 style="color: cyan;">Bio/Tagline:</h4>
            <p>${data.bio || 'No bio provided.'}</p>
        </div>
        <div style="padding-top: 15px; border-top: 1px dashed #333;">
            <h4 style="color: cyan;">Featured Games:</h4>
            <p>${gamesHtml || 'No featured games.'}</p>
        </div>
        `;
}

// Placeholder for unblock function
async function unblockUser(blockedId) {
    if (!currentUser) return;
    const blockId = `${currentUser.uid}_${blockedId}`; 
    
    try {
        await db.collection("blocks").doc(blockId).delete();
        alert("User unblocked.");
        await loadBlocks();
        showTab('allUsers');
    } catch (e) {
        console.error("Unblock User Error:", e);
        alert("Error unblocking user: " + e.message);
    }
}

// Placeholder for chat function
function startChat(friendId) {
    alert(`Starting chat with ${friendId.substring(0, 8)}... (Messaging not fully implemented in this demo)`);
    // Logic to set currentChatUid, load messages, etc.
}


// Placeholder for username change logic
async function attemptUsernameChange() {
    // This is the one-time write that requires the unique username index check
    alert("Username change logic is complex and relies on a Cloud Function for uniqueness and atomic update. This client-only button is a placeholder.");
}

// Placeholder for avatar preview
function previewAvatar(input) {
    alert("Avatar upload logic (Firebase Storage) omitted for brevity.");
}

// Initial tab load when the dashboard appears
showTab('allUsers');

</script>
