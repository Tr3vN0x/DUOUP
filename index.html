<?php
// index.php ‚Äî DUO UP SPA (All-in-One)
?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DUO UP</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>

<style>
body {
    margin:0;
    font-family:'Orbitron',sans-serif;
    background:#0b0b0b;
    color:white;
}

.hidden { display:none; }

.card {
    position:relative;
    width:260px;
    padding:20px;
    margin:15px;
    background:#181818;
    border-radius:10px;
    box-shadow:0 0 20px rgba(0,255,255,.4);
    text-align:center;
}

.avatar {
    width:80px;
    height:80px;
    border-radius:50%;
    border:3px solid magenta;
    margin-bottom:10px;
}

/* üî• DEV BADGE 67 */
.dev-badge-67 {
    position:absolute;
    top:10px;
    right:10px;
    padding:6px 10px;
    font-size:.7em;
    font-weight:900;
    letter-spacing:1px;
    border-radius:6px;
    background:linear-gradient(45deg,#00ffff,#ff00ff,#00ffff);
    color:#0b0b0b;
    text-transform:uppercase;
    box-shadow:
        0 0 10px cyan,
        0 0 20px magenta,
        inset 0 0 10px rgba(255,255,255,.4);
    animation: devPulse 1.6s infinite alternate;
    z-index:10;
}

@keyframes devPulse {
    from {
        transform:scale(1);
        box-shadow:0 0 10px cyan,0 0 20px magenta;
    }
    to {
        transform:scale(1.15);
        box-shadow:0 0 30px cyan,0 0 50px magenta;
    }
}

button {
    padding:8px 14px;
    background:transparent;
    border:2px solid cyan;
    color:white;
    border-radius:6px;
    cursor:pointer;
    box-shadow:0 0 10px cyan;
}
button:hover {
    border-color:magenta;
    box-shadow:0 0 15px magenta;
}
</style>
</head>

<body>

<div style="text-align:center;padding:20px;">
    <h1>‚ö° DUO UP</h1>
    <button onclick="login()">Login</button>
    <button onclick="logout()">Logout</button>
</div>

<div id="userArea" style="display:flex;flex-wrap:wrap;justify-content:center;"></div>

<script>
/* ===========================
   FIREBASE CONFIG
   =========================== */
firebase.initializeApp({
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_DOMAIN",
    projectId: "YOUR_PROJECT_ID"
});

const auth = firebase.auth();
const db = firebase.firestore();

/* ===========================
   DEV BADGE SYSTEM (UID ONLY)
   =========================== */
const DEV_BADGE_67_UIDS = [
    "hmXTc2hkF5Vvqrn8xuNjK3S9ybS2",
    "kHsYFJVHCGfQzI16nJH0mg1rv7u1"
];

function renderDevBadge(uid) {
    return DEV_BADGE_67_UIDS.includes(uid)
        ? `<div class="dev-badge-67">DEV 67</div>`
        : "";
}

/* ===========================
   AUTH
   =========================== */
function login() {
    auth.signInWithPopup(new firebase.auth.GoogleAuthProvider());
}

function logout() {
    auth.signOut();
}

/* ===========================
   RENDER USERS
   =========================== */
function renderUser(user) {
    const div = document.createElement("div");
    div.className = "card";
    div.innerHTML = `
        ${renderDevBadge(user.id)}
        <img class="avatar" src="${user.photoURL || ''}">
        <h3>${user.displayName || "Unknown"}</h3>
        <p>${user.id}</p>
    `;
    document.getElementById("userArea").appendChild(div);
}

/* ===========================
   AUTH STATE
   =========================== */
auth.onAuthStateChanged(user => {
    document.getElementById("userArea").innerHTML = "";
    if (!user) return;

    // Show logged-in user
    renderUser(user);

    // Show all users from Firestore
    db.collection("users").get().then(snap => {
        snap.forEach(doc => {
            renderUser({ id: doc.id, ...doc.data() });
        });
    });
});
</script>

</body>
</html>


    // Highlight active navigation button
    document.querySelectorAll('#navigationBar button').forEach(btn => btn.classList.remove('active'));
    document.getElementById('tab-' + tab)?.classList.add('active');


    switch(tab){
        case 'allUsers': loadAllUsers(); break;
        case 'search': filterSearchResults(); break;
        case 'friends': loadFriends(); break;
        case 'messaging': loadChatList(); break;
        case 'profile': loadUserProfile(); toggleLfdCategory(); break;
        default: break;
    }
    document.getElementById(tab+'Tab')?.classList.remove('hidden'); 
}

// ---------------------------
// CORE DATA LOADING (Fixed LoadAllUsers Query & Error Handling)
// ---------------------------
async function loadAllUsers(){
    if(!currentUser) return;
    const container=document.getElementById('allUsersTab');
    // Display loading message first
    container.innerHTML="<p style='width:100%; text-align:center;'>Loading Suggested Players... Please wait.</p>";
    
    try{
        // 1. Load ALL users 
        const snapshot=await db.collection('users').get();
        allUsersCache=snapshot.docs.map(d=>({id:d.id,...d.data()}));
        
        // 2. Load all friend requests involving the current user 
        const requestsSnap = await db.collection('friendRequests')
            .where('participants', 'array-contains', currentUser.uid) 
            .get();
            
        requestCache = {};
        requestsSnap.forEach(doc => {
            const data = doc.data();
            const otherUid = data.participants.find(uid => uid !== currentUser.uid);

            if (otherUid) {
                requestCache[otherUid] = { 
                    id: doc.id, 
                    status: data.status, 
                    senderId: data.senderId,
                    receiverId: data.receiverId
                };
            }
        });

        // --- FIX: CLEAR CONTAINER BEFORE RENDERING ---
        container.innerHTML=""; 

        // 3. Render the cards
        let renderedCount = 0;
        allUsersCache.forEach(user=>{
            if(user.id===currentUser.uid) return;
            const card=renderUserCard(user.id, user, requestCache[user.id]);
            if (card) {
                container.appendChild(card);
                renderedCount++;
            }
        });
        
        if (renderedCount === 0) {
            container.innerHTML = '<p style="width:100%; text-align:center; color:#ff00ff;">No other users found in the system yet.</p>';
        }

    }catch(e){ 
        // --- IMPROVED ERROR DISPLAY ---
        console.error("Error loading users:", e);
        container.innerHTML=`<p style="width:100%; text-align:center; color:red;">
            NETWORK ERROR: Failed to load user data. Check console for details.
            </p>`; 
    }
}

// ---------------------------
// User Rendering Functions
// ---------------------------
function renderUserCard(uid, data, requestInfo){
    if(!data) return null;
    const card=document.createElement('div');
    card.className='card';
    card.onclick=()=>viewProfile(uid, data);
    const statusClass=(data.status||'Online').replace(/\s/g,'').toLowerCase();
    
    // --- COMBINE BADGES ---
    const badge = getCoFounderBadge(uid) + getCustomBadge(uid);
    // ----------------------
    
    const gameCategory = data.gameCategory || 'Other';
    const gameCategoryClass = `game-category-${gameCategory.toLowerCase().replace(/\s/g, '')}`;
    const gameRole = data.gameRole || 'Generalist';
    const lfdCategory = data.lfdCategory || null; 

    let cardButtons;
    
    if (requestInfo) {
        if (requestInfo.status === 'pending') {
            if (requestInfo.senderId === currentUser.uid) {
                cardButtons = `<button class="neon-btn pending" disabled>Pending (Waiting for reply)</button>`; 
            } else {
                cardButtons = `<button class="neon-btn add" onclick="event.stopPropagation(); acceptFriendRequest('${requestInfo.id}')">Accept Request</button>
                               <button class="neon-btn remove" onclick="event.stopPropagation(); rejectFriendRequest('${requestInfo.id}')">Reject</button>`;
            }
        } else if (requestInfo.status === 'accepted') {
            cardButtons = `<button class="neon-btn" style="border-color:lime; color:lime;" onclick="event.stopPropagation(); showTab('messaging'); selectChat('${getChatId(uid)}', '${uid}')">Duo Active</button>`;
        } else {
            // Rejected or other state, allow new request
            cardButtons = `<button class="neon-btn add" onclick="event.stopPropagation(); sendFriendRequest('${uid}')">Send Request</button>`;
        }
    } else {
        cardButtons = `<button class="neon-btn add" onclick="event.stopPropagation(); sendFriendRequest('${uid}')">Send Request</button>`;
    }
    
    let lfdCategoryDisplay = '';
    if (data.status === 'LFD' && lfdCategory) {
        lfdCategoryDisplay = `<div class="lfd-category">${lfdCategory}</div>`;
    }

    card.innerHTML=`
        <div class="card-content-box">
        <img src="${data.profileImageUrl||DEFAULT_AVATAR}" class="avatar">
        <div class="nickname-group">
            <h3 style="margin:0;">${data.nickname||'Unknown'}</h3>
            ${badge}
        </div>
        <div class="game-category ${gameCategoryClass}">${gameCategory.replace(/([A-Z])/g, ' $1').trim()}</div>
        <div class="game-role">${gameRole.replace(/([A-Z])/g, ' $1').trim()}</div>
        ${lfdCategoryDisplay} 
        <div class="skill-rating">${'‚≠ê'.repeat(data.skillRating||3)}</div>
        <div class="status-indicator status-${statusClass}">${data.status||'Online'}</div>
        <p style="margin:5px 0; font-size:0.9em; text-align:center; color:#ccc;">${data.bio||'No bio provided.'}</p>
        </div>
        ${cardButtons}
    `;
    return card;
}

function renderDuoCard(uid, data) {
    if(!data) return null;
    const card = document.createElement('div');
    card.className = 'card';
    card.onclick = () => viewProfile(uid, data); 

    const statusClass = (data.status || 'Online').replace(/\s/g,'').toLowerCase();
    
    // --- COMBINE BADGES ---
    const badge = getCoFounderBadge(uid) + getCustomBadge(uid);
    // ----------------------
    
    const chatId = getChatId(uid);

    card.innerHTML = `
        <div class="card-content-box" style="border-bottom: none;">
            <img src="${data.profileImageUrl||DEFAULT_AVATAR}" class="avatar">
            <div class="nickname-group">
                <h3 style="margin:0;">${data.nickname||'Unknown'}</h3>
                ${badge}
            </div>
            <p style="margin:5px 0; font-size:0.9em; color:lime;">DUO PARTNER</p>
            <div class="status-indicator status-${statusClass}">${data.status||'Online'}</div>
        </div>
        <button class="neon-btn" style="border-color:magenta; box-shadow:0 0 10px magenta;" 
                onclick="event.stopPropagation(); showTab('messaging'); selectChat('${chatId}', '${uid}')">
            Message Duo
        </button>
    `;
    return card;
}

// ---------------------------
// PROFILE EDITOR FUNCTIONS
// ---------------------------

// NEW FUNCTION: Updates the profile avatar preview from the URL field
function previewUrl(url) {
    // Basic check to prevent breakage if user clears the field
    document.getElementById('profileAvatar').src = url.trim() || DEFAULT_AVATAR;
}

// NOTE: The uploadAvatar function is DELETED for the URL-only approach.

async function saveProfile() {
    if (!currentUser) return;
    document.getElementById('saveMessage').textContent = 'Saving profile...';
    
    try {
        const nicknameInput = document.getElementById('profileNickname');
        const nickname = nicknameInput.value.trim();
        const bio = document.getElementById('profileBio').value.trim();
        const skillRating = parseInt(document.getElementById('profileSkillRating').value);
        const gameCategory = document.getElementById('profileGameCategory').value;
        const gameRole = document.getElementById('profileGameRole').value;
        const status = document.getElementById('profileStatus').value;
        const lfdCategory = document.getElementById('profileLfdCategory').value;
        
        // üö® PROFILE PICTURE INTEGRATION (Updated for URL input)
        // Get the value directly from the new URL input field
        let profileImageUrl = document.getElementById('profileImageUrlInput').value.trim() || DEFAULT_AVATAR;

        const updateData = {
            bio,
            skillRating,
            gameCategory,
            gameRole,
            status,
            profileImageUrl: profileImageUrl, // <--- New URL is saved directly
            lfdCategory: status === 'LFD' ? lfdCategory : null,
        };

        // 2. Handle Nickname Change (if allowed)
        if (nickname !== currentProfileData.nickname) {
            if (currentProfileData.nicknameChangeUsed === true) {
                 alert('You have already used your one-time nickname change.');
                 nicknameInput.value = currentProfileData.nickname; // Revert change
                 document.getElementById('saveMessage').textContent = 'Error: Nickname change limit reached.';
                 return;
            }
            updateData.nickname = nickname;
            updateData.nicknameChangeUsed = true;
        }

        // 3. Update Firestore
        await db.collection('users').doc(currentUser.uid).update(updateData);

        // Update local cache and UI
        currentProfileData = { ...currentProfileData, ...updateData };
        document.getElementById('saveMessage').textContent = 'Profile saved successfully! Reloading data...';
        document.getElementById('nicknameChangeInfo').textContent = '(Nickname change is now used.)';
        
        // Update the welcome message immediately with the new nickname
        document.getElementById('welcome').textContent = `WELCOME ${nickname.toUpperCase()} TO DUO UP!`;

        // Re-load to refresh all UI components
        setTimeout(() => {
            showTab('profile'); // Keep user on profile page
            loadAllUsers(); // Refresh the main user list/cache
        }, 1000);

    } catch (e) {
        console.error("Error saving profile: ", e);
        document.getElementById('saveMessage').textContent = `Error saving profile: ${e.message}`;
    }
}

async function loadUserProfile() {
    if (!currentUser) return;

    try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (!userDoc.exists) {
            document.getElementById('profileTab').innerHTML = '<p style="color:red;">Profile not found. Please log out and back in.</p>';
            return;
        }

        const data = userDoc.data();
        currentProfileData = data;

        // Update editor fields
        document.getElementById('profileAvatar').src = data.profileImageUrl || DEFAULT_AVATAR;
        
        // === NEW: Set the value of the new input field ===
        document.getElementById('profileImageUrlInput').value = data.profileImageUrl || DEFAULT_AVATAR;
        // ================================================
        
        document.getElementById('profileNickname').value = data.nickname || '';
        document.getElementById('profileBio').value = data.bio || '';
        document.getElementById('profileSkillRating').value = data.skillRating || 3;
        document.getElementById('profileGameCategory').value = data.gameCategory || 'Other';
        document.getElementById('profileGameRole').value = data.gameRole || 'Generalist';
        document.getElementById('profileStatus').value = data.status || 'Online';
        document.getElementById('profileLfdCategory').value = data.lfdCategory || 'Duo';

        // Update nickname info message
        if (data.nicknameChangeUsed) {
            document.getElementById('profileNickname').disabled = true;
            document.getElementById('nicknameChangeInfo').textContent = '(Nickname change has been used. Contact support for further changes.)';
            document.getElementById('nicknameChangeInfo').style.color = 'red';
        } else {
            document.getElementById('profileNickname').disabled = false;
            document.getElementById('nicknameChangeInfo').textContent = '(You get one free nickname change.)';
            document.getElementById('nicknameChangeInfo').style.color = 'yellow';
        }

        toggleLfdCategory();
        document.getElementById('saveMessage').textContent = ''; // Clear previous save messages
        
    } catch (e) {
        console.error("Error loading user profile:", e);
    }
}

function toggleLfdCategory() {
    const status = document.getElementById('profileStatus').value;
    const lfdGroup = document.getElementById('lfdCategoryGroup');
    if (status === 'LFD') {
        lfdGroup.classList.remove('hidden');
    } else {
        lfdGroup.classList.add('hidden');
    }
}

// ---------------------------
// DUO/FRIENDS/MESSAGING FUNCTIONS (IMPLEMENTATION)
// ---------------------------

/**
 * Sends a friend request.
 * FIX: Now uses getCanonicalId and set() to ensure the document ID matches 
 * the ID required by the Firestore Security Rules.
 * NEW: Uses a styled alert for success message.
 */
async function sendFriendRequest(receiverId) {
    if (receiverId === currentUser.uid) return alert("Cannot send request to yourself.");

    const receiver = findUserInCache(receiverId);
    if (!receiver) return alert("Error: User not found in cache.");

    // 1. Calculate the required document ID (Canonical ID)
    const canonicalDuoId = getCanonicalId(currentUser.uid, receiverId);

    // Check if a request already exists
    const existingRequest = requestCache[receiverId];
    if (existingRequest) {
        if (existingRequest.status === 'pending') {
            return alert(`A pending request to ${receiver.nickname} already exists.`);
        }
        if (existingRequest.status === 'accepted') {
            return alert(`${receiver.nickname} is already your Duo partner!`);
        }
    }

    try {
        // 2. Use .doc(ID).set() to ensure the document ID is the canonical one
        await db.collection('friendRequests').doc(canonicalDuoId).set({
            status: 'pending',
            senderId: currentUser.uid,
            receiverId: receiverId,
            participants: [currentUser.uid, receiverId],
            // FIX: Using 'createdAt' as required by the security rules
            createdAt: firebase.firestore.FieldValue.serverTimestamp() 
        });

        // ‚ú® NEW FEATURE: Custom Alert for "Request sent!" in Yellow
        const alertStyle = "background-color: yellow; color: black; border: 2px solid orange; padding: 10px; border-radius: 5px;";
        console.warn(`%cRequest sent to ${receiver.nickname}!`, alertStyle);
        alert(`Request sent to ${receiver.nickname}!`); // Standard alert for immediate user feedback

        // Refresh the current view to update the button status
        loadAllUsers(); 
    } catch (e) {
        console.error("Error sending request:", e);
        alert("Failed to send request: " + e.message);
    }
}

async function acceptFriendRequest(requestId) {
    try {
        await db.collection('friendRequests').doc(requestId).update({
            status: 'accepted',
            acceptedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        alert('Friend request accepted! You are now a Duo.');
        // Re-load the friends tab
        loadFriends(); 
        // Also refresh the all users list in case this was initiated from there
        loadAllUsers();
    } catch (e) {
        console.error("Error accepting request:", e);
        alert("Failed to accept request: " + e.message);
    }
}

async function rejectFriendRequest(requestId) {
    try {
        // We delete the request upon rejection
        await db.collection('friendRequests').doc(requestId).delete();
        alert('Friend request rejected.');
        // Re-load the friends tab
        loadFriends(); 
        // Also refresh the all users list
        loadAllUsers();
    } catch (e) {
        console.error("Error rejecting request:", e);
        alert("Failed to reject request: " + e.message);
    }
}

async function loadFriends() {
    if (!currentUser) return;
    
    const pendingContainer = document.getElementById('pendingRequestsList');
    const acceptedContainer = document.getElementById('friendList');

    pendingContainer.innerHTML = '<p style="width:100%; text-align:center;">Loading pending requests...</p>';
    acceptedContainer.innerHTML = '<p style="width:100%; text-align:center; color:magenta;">Loading accepted duos...</p>';
    
    // CRITICAL: Ensure all users are loaded into cache first for rendering names/avatars
    if (allUsersCache.length === 0) {
        // Call loadAllUsers to populate both allUsersCache and requestCache
        await loadAllUsers(); 
        // Note: loadAllUsers updates allUsersTab, but we continue here for friendsTab
    }

    pendingContainer.innerHTML = '';
    acceptedContainer.innerHTML = '';
    
    let pendingCount = 0;
    let acceptedCount = 0;

    try {
        // We rely on requestCache being populated by loadAllUsers()
        for (const otherUid in requestCache) {
            const requestInfo = requestCache[otherUid];
            const otherUserData = findUserInCache(otherUid);

            if (!otherUserData) continue; // Skip if user data is missing

            if (requestInfo.status === 'pending' && requestInfo.receiverId === currentUser.uid) {
                // Incoming Pending Request (I must accept/reject)
                // Note: We use renderUserCard here because it has the accept/reject buttons
                const card = renderUserCard(otherUid, otherUserData, requestInfo);
                if (card) {
                    pendingContainer.appendChild(card);
                    pendingCount++;
                }
            } else if (requestInfo.status === 'accepted') {
                // Accepted Duo
                const card = renderDuoCard(otherUid, otherUserData);
                if (card) {
                    acceptedContainer.appendChild(card);
                    acceptedCount++;
                }
            }
        }

        if (pendingCount === 0) {
            pendingContainer.innerHTML = '<p style="width:100%; text-align:center; color:cyan;">No pending requests at this time.</p>';
        }

        if (acceptedCount === 0) {
            acceptedContainer.innerHTML = '<p style="width:100%; text-align:center; color:magenta;">You have no active Duo partners yet. Go find some!</p>';
        }
        
    } catch(e) {
        console.error("Error loading friends:", e);
        pendingContainer.innerHTML = '<p style="width:100%; text-align:center; color:red;">Error loading requests.</p>';
        acceptedContainer.innerHTML = '<p style="width:100%; text-align:center; color:red;">Error loading duos.</p>';
    }
}


async function loadChatList() {
    if (!currentUser) return;
    const duoListContainer = document.getElementById('activeDuoList');
    duoListContainer.innerHTML = '<p style="text-align:center;">Loading Duos...</p>';
    
    // CRITICAL: Ensure all users and requests are loaded/cached
    if (allUsersCache.length === 0) {
        await loadAllUsers(); 
    }

    let chatListContent = '';
    let duoCount = 0;

    try {
        // We rely on requestCache being populated by loadAllUsers()
        for (const otherUid in requestCache) {
            const requestInfo = requestCache[otherUid];
            const partnerData = findUserInCache(otherUid);

            if (requestInfo.status === 'accepted' && partnerData) {
                const chatId = getChatId(otherUid);
                const isActive = chatId === currentChatId ? 'active' : '';

                chatListContent += `
                    <div class="chat-entry ${isActive}" onclick="selectChat('${chatId}', '${otherUid}')">
                        <span style="font-weight:bold; color:lime;">${partnerData.nickname}</span> 
                        <span style="font-size:0.8em; opacity:0.7;">(${partnerData.status || 'Online'})</span>
                    </div>
                `;
                duoCount++;
            }
        }
        
        duoListContainer.innerHTML = chatListContent;

        if (duoCount === 0) {
             duoListContainer.innerHTML = '<p style="text-align:center; color:magenta;">No active Duos to message.</p>';
        }

    } catch(e) {
        console.error("Error loading chat list:", e);
        duoListContainer.innerHTML = '<p style="text-align:center; color:red;">Error loading chat list.</p>';
    }
}


function selectChat(chatId, partnerUid) {
    // 1. Stop previous listener
    if (chatListener) chatListener(); 
    
    // 2. Update list highlighting
    document.querySelectorAll('.chat-entry').forEach(e => e.classList.remove('active'));
    // Simple way to select the entry: find the one with the correct onclick attribute
    const selectedEntry = document.querySelector(`.chat-entry[onclick*="'${chatId}'"]`);
    if (selectedEntry) selectedEntry.classList.add('active');


    // 3. Set new chat info
    currentChatId = chatId;
    currentChatPartnerId = partnerUid;
    const partner = findUserInCache(partnerUid);
    
    document.getElementById('chatHeader').textContent = `Chatting with: ${partner ? partner.nickname : 'Unknown Duo'}`;
    document.getElementById('messageDisplay').innerHTML = 'Connecting...';
    document.getElementById('messageInputArea').classList.remove('hidden');
    
    // 4. Start new listener
    chatListener = db.collection('chats').doc(chatId).collection('messages')
        .orderBy('timestamp', 'asc')
        .onSnapshot(snapshot => {
            // Note: This only clears on first load or manual refresh. 
            // docChanges() handles updates more efficiently but we'll stick to a full refresh for simplicity.
            document.getElementById('messageDisplay').innerHTML = ''; 
            snapshot.docs.forEach(doc => {
                displayMessage(doc.data());
            });
            // Auto-scroll to bottom
            const display = document.getElementById('messageDisplay');
            display.scrollTop = display.scrollHeight;
        }, error => {
            console.error("Chat listener error:", error);
            document.getElementById('messageDisplay').innerHTML = '<p style="color:red;">Error loading messages.</p>';
        });
}

function displayMessage(messageData) {
    const display = document.getElementById('messageDisplay');
    const msgDiv = document.createElement('div');
    const isSent = messageData.senderId === currentUser.uid;
    msgDiv.className = `message ${isSent ? 'sent' : 'received'}`;
    
    const time = messageData.timestamp ? new Date(messageData.timestamp.toMillis()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '...';
    
    msgDiv.innerHTML = `
        ${messageData.text}
        <span>${isSent ? 'You' : findUserInCache(messageData.senderId)?.nickname || 'Duo'} - ${time}</span>
    `;
    display.appendChild(msgDiv);
}

/**
 * Sends a message to the currently selected chat.
 * CRITICAL FIX: Added chatId to match the Firestore Security Rule validation.
 */
async function sendMessage() {
    const input = document.getElementById('messageInput');
    const text = input.value.trim();
    
    if (!text || !currentChatId || !currentUser) {
        console.warn("Message not sent: Input is empty, chat is not selected, or user is not logged in.");
        return;
    }

    // Disable input and button to prevent double send
    input.disabled = true;
    document.getElementById('sendMessageBtn').disabled = true;
    
    try {
        await db.collection('chats').doc(currentChatId).collection('messages').add({
            text: text,
            senderId: currentUser.uid,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            // --- CRITICAL FIX START ---
            chatId: currentChatId // <-- REQUIRED by your Firestore Security Rule
            // --- CRITICAL FIX END ---
        });
        
        // Success: Clear input and re-enable controls
        input.value = ''; 
        input.disabled = false;
        document.getElementById('sendMessageBtn').disabled = false;
        
    } catch (e) {
        // FAILURE: Re-enable controls and show error
        input.disabled = false;
        document.getElementById('sendMessageBtn').disabled = false;

        alert(`Failed to send message. Please check the console for the error. (Error Code: ${e.code || 'UNKNOWN'}). If this is a 'Permission Denied' error, the issue was the missing 'chatId' field!`);
        console.error("!!! FATAL CHAT WRITE ERROR !!!", e);
    }
}


function viewProfile(uid, data) {
    // This is the viewing logic, not the editing logic
    showTab('viewProfile'); 
    
    const container = document.getElementById('viewProfileContent');
    container.innerHTML = 'Loading profile details...';
    
    const statusClass = (data.status || 'Online').replace(/\s/g,'').toLowerCase();
    const gameCategory = data.gameCategory || 'Other';
    const gameCategoryDisplay = gameCategory.replace(/([A-Z])/g, ' $1').trim();
    const gameRoleDisplay = (data.gameRole || 'Generalist').replace(/([A-Z])/g, ' $1').trim();
    const lfdCategory = data.lfdCategory || 'N/A';
    
    // --- COMBINE BADGES ---
    const badge = getCoFounderBadge(uid) + getCustomBadge(uid);
    // ----------------------

    let profileActions = '';
    const requestInfo = requestCache[uid];

    if (requestInfo && requestInfo.status === 'accepted') {
        profileActions = `<button class="neon-btn" style="border-color:lime; color:lime;" onclick="event.stopPropagation(); showTab('messaging'); selectChat('${getChatId(uid)}', '${uid}')">Message Duo</button>`;
    } else if (requestInfo && requestInfo.status === 'pending') {
        // If pending, check if it's an incoming request
        if (requestInfo.receiverId === currentUser.uid) {
            profileActions = `<button class="neon-btn add" onclick="event.stopPropagation(); acceptFriendRequest('${requestInfo.id}')">Accept Request</button>
                              <button class="neon-btn remove" onclick="event.stopPropagation(); rejectFriendRequest('${requestInfo.id}')">Reject</button>`;
        } else {
            profileActions = `<button class="neon-btn pending" disabled>Pending Request</button>`;
        }
    } else {
        profileActions = `<button class="neon-btn add" onclick="event.stopPropagation(); sendFriendRequest('${uid}')">Send Request</button>`;
    }
    
    // Hide actions for own profile
    if (uid === currentUser.uid) {
         profileActions = '<p style="color:cyan;">This is your profile.</p>';
    }


    container.innerHTML = `
        <img src="${data.profileImageUrl||DEFAULT_AVATAR}" class="avatar" style="width:120px; height:120px; border-color:cyan;">
        <div class="nickname-group" style="margin-bottom:15px;">
            <h2 style="margin:0;">${data.nickname||'Unknown Duo'}</h2>
            ${badge}
        </div>
        <p style="font-style:italic; color:#aaa; margin-bottom:20px; text-align:center;">"${data.bio||'No bio provided.'}"</p>
        
        <div class="profile-stat">
            <span>Skill Rating:</span>
            <span>${'‚≠ê'.repeat(data.skillRating||3)}</span>
        </div>
        <div class="profile-stat">
            <span>Primary Game:</span>
            <span>${gameCategoryDisplay}</span>
        </div>
        <div class="profile-stat">
            <span>Role/Mode:</span>
            <span>${gameRoleDisplay}</span>
        </div>
        <div class="profile-stat">
            <span>Status:</span>
            <span class="status-indicator status-${statusClass}">${data.status||'Online'}</span>
        </div>
        ${data.status === 'LFD' ? `<div class="profile-stat"><span>LFD Goal:</span><span>${lfdCategory}</span></div>` : ''}

        <div style="margin-top:30px;">
            ${profileActions}
        </div>
    `;
}

// ----------------------------------------------------
// 3. SEARCH FILTER LOGIC
// ----------------------------------------------------

function filterSearchResults() {
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '';
    if (allUsersCache.length === 0) {
        resultsContainer.innerHTML = '<p style="width:100%; text-align:center;">Loading users...</p>';
        return;
    }

    const searchInput = document.getElementById('searchInput').value.toLowerCase();
    const statusFilter = document.getElementById('statusFilter').value;
    const gameCategoryFilter = document.getElementById('gameCategoryFilter').value;
    const gameRoleFilter = document.getElementById('gameRoleFilter').value;
    const lfdCategoryFilter = document.getElementById('lfdCategoryFilter').value;

    const filteredUsers = allUsersCache.filter(user => {
        if (user.id === currentUser.uid) return false;

        // Text Search (Nickname or Bio)
        const matchesText = !searchInput || 
                            user.nickname.toLowerCase().includes(searchInput) || 
                            (user.bio && user.bio.toLowerCase().includes(searchInput));
        if (!matchesText) return false;

        // Status Filter
        const matchesStatus = !statusFilter || user.status === statusFilter;
        if (!matchesStatus) return false;

        // Game/Category Filter
        const matchesGameCategory = !gameCategoryFilter || user.gameCategory === gameCategoryFilter;
        if (!matchesGameCategory) return false;

        // Game Role Filter
        const matchesGameRole = !gameRoleFilter || user.gameRole === gameRoleFilter;
        if (!matchesGameRole) return false;

        // LFD Category Filter (only applies if user status is LFD)
        const matchesLfdCategory = !lfdCategoryFilter || (user.status === 'LFD' && user.lfdCategory === lfdCategoryFilter);
        if (!matchesLfdCategory) return false;

        return true;
    });

    if (filteredUsers.length === 0) {
        resultsContainer.innerHTML = '<p style="width:100%; text-align:center;">No matching players found.</p>';
        return;
    }

    filteredUsers.forEach(user => {
        const card = renderUserCard(user.id, user, requestCache[user.id]);
        if (card) resultsContainer.appendChild(card);
    });
}


// FIX for jQuery style selector not being available
if (typeof NodeList.prototype.forEach !== 'function') {
    NodeList.prototype.forEach = Array.prototype.forEach;
}
if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
    Element.prototype.closest = function(s) {
        let el = this;
        do {
            if (el.matches(s)) return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}
// Simple contains polyfill/extension for querySelector
if (window.Element && !Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}
document.querySelector = (function(orig) {
    return function(selector) {
        if (selector.includes(':contains')) {
            const [base, text] = selector.split(':contains');
            const target = text.match(/\((.*?)\)/)[1].replace(/['"]/g, '');
            // We use Array.from and find for a safer check instead of NodeList iteration
            return Array.from(document.querySelectorAll(base)).find(e => e.textContent.includes(target));
        }
        return orig.call(this, selector);
    };
})(document.querySelector);


// ----------------------------------------------------
// 4. START APPLICATION
// ----------------------------------------------------
initFirebase();
</script>

</body>
</html>

